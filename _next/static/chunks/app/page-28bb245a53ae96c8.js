(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{11:(e,n,o)=>{Promise.resolve().then(o.bind(o,4661))},4661:(e,n,o)=>{"use strict";o.d(n,{Canvas:()=>t});var l=o(5155),r=o(2115);function t(e){let{className:n,squareSize:t=12,gapSize:i=4,blinkProbability:c=.25,freqRange:u=[.1,.3]}=e,s=(0,r.useRef)(null),f=(0,r.useRef)(null),[_,m]=(0,r.useState)(null);return(0,r.useEffect)(()=>{let{current:e}=s;if(e&&!_){let n=getComputedStyle(document.documentElement),l=n.getPropertyValue("--color-light-blue"),r=n.getPropertyValue("--color-website");o.e(814).then(o.bind(o,5814)).then(n=>{let{default:o}=n,s=new o(e);s.load("#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_color_background;\nuniform vec3 u_color_square;\nuniform float u_square_size;\nuniform float u_gap_size;\nuniform float u_blink_probability;\nuniform float u_min_flicker_freq;\nuniform float u_max_flicker_freq;\n\n// A simple hash function to generate a pseudo-random value from a 2D coordinate.\nfloat random(vec2 st, float seed) {\n  return fract(sin(dot(st, vec2(12.9898, 78.233) + seed)) * 43758.5453123);\n}\n\nvoid main() {\n  // Get pixel coordinate\n  vec2 uv = gl_FragCoord.xy;\n\n  // Rotate the grid 45\xb0 around the center of the canvas.\n  float angle = 3.14159 / 4.0;  // 45\xb0 in radians.\n  mat2 rot = mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n  vec2 center = u_resolution * 0.5;\n  uv = rot * (uv - center) + center;\n\n  // Each cell is 16px (12px square + 4px gap)\n  float cellSize = u_square_size + u_gap_size;\n  \n  // Determine which cell we're in and the local position within that cell.\n  vec2 cell = floor(uv / cellSize);\n  vec2 cellPos = mod(uv, cellSize);\n  \n  // If the current pixel is within the gap area, output the background color (black).\n  if(cellPos.x >= u_square_size || cellPos.y >= u_square_size) {\n    gl_FragColor = vec4(u_color_background, 1.0);\n    return;\n  }\n  \n  // Generate a random value for the cell.\n  float rnd = random(cell, 0.0);\n  // Set a frequency range for slow blinking: from 0.2Hz to 0.5Hz.\n  float freq = mix(u_min_flicker_freq, u_max_flicker_freq, rnd);\n  // Move the time randomly forward for each cell\n  float time = u_time + 100000.0 * rnd;\n  // Compute a phase value that includes a random phase offset.\n  float phase = time * 2.0 * 3.14159 * freq + rnd * 6.28318;\n \n  // Compute an integer-like cycle count for the blink.\n  // This increases by 1 each blink cycle.\n  // Derive the cycle count from the phase (each full 2Ï€ period is one cycle).\n  float cycle = floor(phase / (2.0 * 3.14159));\n  \n  // Choose the target color based on the cycle.\n  bool isBrightCycle = (mod(cycle, 1.0 / u_blink_probability) < 1.0);\n  vec3 targetColor = isBrightCycle ? u_color_square : u_color_square / 2.0;\n\n  // Compute a smooth blink value that oscillates between 0.0 and 1.0.\n  // The sine wave is scaled and offset to yield a smooth transition.\n  float blink = sin(phase) * 0.5 + 0.5;\n\n  // Use the blink value to determine the color of the square.\n  vec3 color = mix(u_color_background, targetColor, blink);\n  gl_FragColor = vec4(color, 1.0);\n}\n"),s.setUniform("u_color_background",...a(r)),s.setUniform("u_color_square",...a(l)),s.setUniform("u_min_flicker_freq",u[0]),s.setUniform("u_max_flicker_freq",u[1]),s.setUniform("u_blink_probability",c),s.setUniform("u_square_size",t*window.devicePixelRatio),s.setUniform("u_gap_size",i*window.devicePixelRatio),s.play(),m(s)}).catch(e=>{console.error(e)})}return()=>{_&&_.destroy()}},[s,_]),(0,l.jsx)("div",{ref:f,className:n,children:(0,l.jsx)("canvas",{ref:s,className:_?"w-full h-full":""})})}function a(e){return[parseInt(e.slice(1,3),16)/255,parseInt(e.slice(3,5),16)/255,parseInt(e.slice(5,7),16)/255]}}},e=>{var n=n=>e(e.s=n);e.O(0,[441,517,358],()=>n(11)),_N_E=e.O()}]);